# イベント関数

<details>

<summary>function onloaded()</summary>

Luaファイルが読み込まれた後に実行されるイベント関数。

Luaタグで指定したファイルはゲーム画面に移る直後に読み込まれる。

**90%くらい使う。**

```lua
function onloaded()
  SCREENMAN:SystemMessage("onloaded")
end
```

</details>

<details>

<summary>function start()</summary>

開始を押して曲が始まる1フレームだけ実行されるイベント関数。

**90%くらい使う。**

```lua
function start()
  SCREENMAN:SystemMessage("start")
end
```

</details>


<details>

<summary>function update()</summary>

楽曲再生中に毎フレーム実行されるイベント関数。

サンプルにもある通り、SongBeatを取得するときに必ず使う。

ていうかギミック譜面のほとんどはあまり避けられないと思う。

```lua
function update()
  local currentBeat = GAMESTATE:GetSongBeat()
  SCREENMAN:SystemMessage(currentBeat)
end
```
</details>

<details>

<summary>function finish()</summary>

楽曲の再生終了時に実行されるイベント関数。

> [!WARNING]
>
> 稀に実行できないバージョンがある。

```lua
function finish()
  SCREENMAN:SystemMessage("finish")
end
```
</details>

<details>

<summary>function ondestroy()</summary>

ゲーム画面終了時に実行されるイベント関数。

読み込みリセットはアプリ側がやってくれる為、使用頻度はそこまで高くない。

> [!IMPORTANT]
> ```lua
> require ”(ファイル名)” 
> ```
> を実行した場合、
> ```lua
> package.loaded[”(ファイル名)”] = nil
> _G[”(ファイル名)”] = nil
> ```
> をこの関数内で実行するとファイルの競合がなくなるので、なるべく書いて欲しい。

```lua
function ondestroy()
  print("lua destroy")
end
```
</details>

<details>

<summary>function onHitNote(id, lane, noteType, judgeType, isAttack)</summary>

ノーツが判定にヒットした時に実行されるイベント関数。
  <details>
  <summary>各引数について</summary>

  |引数|説明|
  |-|-|
  |id|0から始まるノーツ番号|
  |lane|0から数えた左からのレーン数|
  |noteType|ノーツの種類の値|
  |judgeType|判定の種類の値|
  |isAttack|アタックノーツの真偽値|
  </details>
  <details>
  <summary>noteTypeの値について</summary>

  |番号|ノーツの種類|
  |-|-|
  |0|(これって必要？)|
  |1|タップノーツ|
  |2|ロング開始|
  |3|ロング中継|
  |4|ロング終端|
  |5|ファジーノーツ|
  |6|ファジーロング開始|
  |7|ファジーロング中継|
  |8|ファジーロング終端|
  </details>
  <details>
  <summary>judgeTypeの値について</summary>

  |番号|判定の種類|
  |-|-|
  |0|Brilliant|
  |1|Great|
  |2|Fast|
  |3|Slow|
  |4|Bad|
  |5|Missed(onHitNoteでは取得されない)|

  **取得されないのになんで5があるんだよ**
  </details>


```lua
function onHitNote(id, lane, noteType, judgeType, isAttack)
  local src={id,lane,noteType,judgeType,isAttack}
  local dst=table.concat(src,",")
  print(dst)
end
```
</details>
<details>

<summary>function onMissedNote(id, lane, noteType)</summary>

ミスの判定時に実行されるイベント関数。
  <details>
  <summary>各引数について</summary>

  |引数|説明|
  |-|-|
  |id|0から始まるノーツ番号|
  |lane|0から数えた左からのレーン数|
  |noteType|ノーツの種類の値|

  **何故ここにisAttackがないのか**
  ~~要望出してないから~~
  </details>
  <details>
  <summary>noteTypeの値について</summary>

  |番号|ノーツの種類|
  |-|-|
  |0|(**マジでこれって必要？**)|
  |1|タップノーツ|
  |2|ロング開始|
  |3|ロング中継|
  |4|ロング終端|
  |5|ファジーノーツ|
  |6|ファジーロング開始|
  |7|ファジーロング中継|
  |8|ファジーロング終端|
  </details>

```lua
function onMissedNote(id, lane, noteType)
  local src={id,lane,noteType}
  local dst=table.concat(src,",")
  print(dst)
end
```
</details>

<details>

<summary>function onSpawnNote(noteController)</summary>

ノーツが生成された時に呼ばれるイベント関数。

引数には生成したNoteControllerクラスの参照が取得される。
  <details>
  <summary>NoteControllerクラスについて</summary>

  <details>
  <summary>取得のみ可能なプロパティ</summary>
  
  |プロパティ名|型|説明|
  |---|---|---|
  |IsReleased|bool|アクティブ状態から解放したか|
  |NoteIndex|int|0からのノーツ番号|
  |Lane|int|0数えで左側からのレーン数|
  |IsAttack|bool|アタックノーツか|
  |IsMissed|bool|ミスしたか|
  |NoteType|NoteType|ノーツの種類|
  |PosX|float|X座標|
  |JustTime|double|ジャストの時間(秒)|
  |JustBeat|double|ジャストの拍数(スクロールタグ計算済の値)|
  </details>

  <details>
  <summary>アクセス可能な関数</summary>

  <details>
  <summary>SetTexture(Texture texture)</summary>

  戻り値：なし

  引数：Texture

  説明：ノーツのテクスチャを変更。

  ```lua
  NoteTexture = UTIL:LoadTexture("ex.png")
  noteController:SetTexture(NoteTexture)
  ```
  </details>
  <details>
  <summary>EnableDefaultMove(bool enable = true)</summary>

  戻り値：なし

  引数：bool ゲーム側のノーツ移動を有効にするか

  説明：ノーツをLua側で動かしてゲーム側の移動処理が必要ない場合はfalseを指定する。デフォルトはtrueに設定されている。

  ```lua
  noteController:EnableDefaultMove(false)
  ```
  </details>
  <details>
  <summary>SetDelegate(Action<NoteController> noteControllerCallBack)</summary>

  戻り値：なし

  引数：Action<NoteController> 引数を1個持つfunction。ここに関数名がないfunctionを直接書いた方が使い勝手の幅はまあまあ増える。
  
  説明：ノーツが表示されている間、毎フレーム呼ばれる関数を設定。

  ```lua
  noteController:SetDelegate(function ()
    noteController:SetLanePosition(1)
  end)
  ```
  </details>
  <details>
  <summary>SetPosition(float x, float y, float z)</summary>

  戻り値：なし

  引数：float X座標, float Y座標, float Z座標
  
  説明：ノーツ位置を座標で設定。等間隔でノーツを置きたいとかノーツで文字を書きたいとかy軸方向にノーツを置きたいとか特別な理由がない限り、あまり使わない方が良い。

  ```lua
  noteController:SetPosition(0,0,0)
  ```
  </details>
  <details>
  <summary>SetLanePosition(float lane)</summary>

  戻り値：なし

  引数：float 左から0数えのレーン位置
  
  説明：0から数えて左から指定したレーンの位置になるようにノーツのX座標を設定。小数点も可。しかしタップできる範囲が限られている為、他人にやらせる譜面なら **-1～7** に抑えた方が良いだろう。

  ```lua
  noteController:SetLanePosition(-1)
  ```
  </details>
  <details>
  <summary>SetBeatPosition(float beat)</summary>

  戻り値：なし

  引数：float 拍数
  
  説明：判定までの拍数からノーツのZ座標を計算してノーツのZ座標と回転を設定。SetIndividualSpeedが追加されるまではソフランギミックをする時に使用されていた。

  ```lua
  --スクロールタグが実装される前の書き方
  noteController:SetBeatPosition(noteController.JustBeat - GAMESTATE:GetSongBeat())
  ```
  </details>
  <details>
  <summary>SetTimePosition(float time)</summary>

  戻り値：なし

  引数：float 時間(秒)
  
  説明：判定までの時間(秒)からノーツのZ座標を計算してノーツのZ座標と回転を設定。どうしても使わなければならない場合を除き、SetBeatPositionを使った方が良い。

  ```lua
  noteController:SetTimePosition(noteController.JustTime - GAMESTATE:GetSongTime())
  ```
  </details>
  <details>
  <summary>SetSize(float size)</summary>

  戻り値：なし

  引数：float ノーツの大きさ(倍率)
  
  説明：ノーツのサイズを設定。 **使用頻度ほぼ0**。難易度上げに困ったらこれを使かってみるのも良いかもしれない。ブーイングしか来ないと思うが。

  ```lua
  noteController:SetSize(1.5)
  ```
  </details>
  <details>
  <summary>SetAlpha(float alpha)</summary>

  戻り値：なし

  引数：float 透明度
  
  説明：ノーツの透明度(0～1)を設定。これも **使用頻度ほぼ0**。確かUnityでの透過処理はアプリの動作が重くなる原因だった気がするので多様厳禁。

  ```lua
  noteController:SetAlpha(0.5)
  ```
  </details>
  <details>
  <summary>SetAttack(bool isAttack)</summary>

  戻り値：なし

  引数：bool 有効か
  
  説明：アタックノーツを有効にするか設定。アタックノーツが存在する譜面で使用できる。つまり、無かったら使えない。ほとんどの創作譜面製作者は律儀にアタックノーツを設定することはないので、 **使用頻度ほぼ0**。

  ```lua
  noteController:SetAttack(false)
  ```
  </details>
  <details>
  <summary>SetIndividualSpeed(float individualSpeed)</summary>

  戻り値：なし

  引数：float 個別の速度倍率
  
  説明：ノーツ単体(個別)のスピードを設定。これの利点はEnableDefaultMoveを書かなくてもできること。ソフランギミックするなら **これ使え**。

  ```lua
  noteController:SetIndividualSpeed(1.2)
  ```
  </details>

  </details>

  </details>


```lua
function onSpawnNote(noteController)
  -- 100番目のノーツの画像を変更する
  if (noteController.NoteIndex == 100) then
    -- 自身が用意したテクスチャに差し替える
    -- ここでは直前に取得していますが、テクスチャは事前に保持して使いまわすとパフォーマンスが良いです
    local tex = UTIL:LoadTexture("my_noteskin.png")
    noteController:SetTexture(tex)
  end

  -- ロング終端ノーツを透明にする
  if (noteController.NoteType == CS.NoteType.LongEnd) then
    noteController:SetAlpha(0)
  end
end
```
</details>

<details>
<summary>function onSpawnLong(longController)</summary>

ロングが生成された時に呼ばれるイベント関数。

引数には生成したLongControllerクラスの参照が取得される。

尚、使い勝手が悪すぎてほぼ使われていない。
  <details>
  <summary>LongControllerクラスについて</summary>
  <details>
  <summary>取得のみ可能なプロパティ</summary>

  |プロパティ名|型|説明|
  |---|---|---|
  |IsReleased|bool|アクティブ状態から解放したか|
  |CurrentPosX|float|X座標|
  |StartNoteIndex|int|ロング開始のノーツ番号|
  |LastNoteIndex|int|ロング終端のノーツ番号|
  |StartBeatPosition|double|ロング開始の拍数|
  |EndBeatPosition|double|ロング終端の拍数|
  |StartTime|double|ロング開始の時間(秒)|
  |EndTime|double|ロング終端の時間(秒)|
  |LongType|LongType|ロングの種類|
  |TouchId|int|ロングを掴んでいる指のタッチ番号 (無い時は-1)|

  > [!IMPORTANT]
  > ここでの拍数はスクロールタグが適応されていない
  </details>
  <details>
  <summary>アクセス可能な関数</summary>
  <details>
  <summary>SetTexture(Texture texture)</summary>

  戻り値：なし

  引数：Texture
  
  説明：ロングのテクスチャを変更。ほぼ使われていないと前述したが、これはロングのスキン変更に使えるので稀に見かけることがある。

  ```lua
  tex = UTIL:LoadTexture("my_longskin.png")
  longController:SetTexture(tex)
  ```
  </details>
  <details>
  <summary>EnableDefaultMove(bool enable = true)</summary>

  戻り値：なし

  引数：bool 有効にするか
  
  説明：ロングをLua側で動かしてゲーム側の移動処理が必要ない場合はfalseを指定。デフォルトはtrueに設定されている。

  ```lua
  longController:EnableDefaultMove(false)
  ```
  </details>
  <details>
  <summary>SetDelegate(Action<LongController> longControllerCallBack)</summary>

  戻り値：なし

  引数：Action<LongController> 引数を1個持つfunction。ここにも関数名がないfunctionを直接書くことができる。
  
  説明：ロングが表示されている間、毎フレーム呼ばれる関数を設定。

  ```lua
  longController:SetDelegate(function ()
    tex = UTIL:LoadTexture("my_longskin.png")
    longController:SetTexture(tex)
  end)
  ```
  </details>
  <details>
  <summary>SetAlpha(float alpha)</summary>

  戻り値：なし

  引数：float 透明度(0～1)
  
  説明：透明度を設定。敷譜面で、少しでも情けの心があるならばこれを使用することを推奨する。

  ```lua
  longController:SetAlpha(0.5)
  ```
  </details>
  <details>
  <summary>SetPosition(float x, float y, float z)</summary>

  戻り値：なし

  引数：float X座標, float Y座標, float Z座標
  
  説明：ロング位置を座標で設定。

  ```lua
  longController:SetPosition(0,0,0)
  ```
  </details>
  <details>
  <summary>SetBeatPosition(float beat)</summary>

  戻り値：なし

  引数：float 拍数
  
  説明：判定までの拍数からロングのZ座標を計算して設定...とあるが実はこれが思う通りに動かない。そう、 **LongControllerの使い勝手が悪い原因はここにある**。計算の根幹部分の筈なのに返り値が変なので全く使われていない。サポート終了が決まったので、今後もLongControllerを使う人はとても限られてくるだろう。

  ```lua
  --こう書いても全くダメ
  longController:SetBeatPosition(longController.StartBeatPosition - GAMESTATE:GetSongBeat())
  ```
  </details>
  <details>
  <summary>SetTimePosition(float time)</summary>

  戻り値：なし

  引数：float 時間(秒)
  
  説明：判定までの時間(秒)からロングのZ座標を計算して設定...しかし、SetBeatPosition同様、これも変なので全く使われていない。

  ```lua
  --こう書いても全くダメ
  longController:SetTimePosition(longController.StartTime - GAMESTATE:GetSongTime())
  ```
  </details>

  </details>

  </details>

```lua
function onSpawnLong(longController)
  -- 20拍から30拍の間にあるロングの画像を変更する
  local longStartPos = longController.StartBeatPosition
  if(20 < longStartPos and longStartPos < 30) then
    -- 自身が用意したテクスチャに差し替える
    -- ここでは直前に取得していますが、テクスチャは事前に保持して使いまわすとパフォーマンスが良いです
    local tex = UTIL:LoadTexture("my_longskin.png")
    longController:SetTexture(tex)
  end
end
```
</details>
<details>
<summary>function onPause()</summary>

ポーズ時に実行されるイベント関数。

WickyPackのVer.3の時に追加されたやつには驚きを隠せなかった。

```lua
function onPause()
  SCREENMAN:SystemMessage("onPause")
end
```
</details>
<details>
<summary>function onResume()</summary>

ポーズから再開時に実行されるイベント関数。

```lua
function onResume()
  SCREENMAN:SystemMessage("onResume")
end
```
</details>
<details>
<summary>function onGameOver()</summary>

楽曲の途中でゲームオーバーになった時に呼ばれるイベント関数。

譜面プレビューではゲームオーバーが無効になっているため、この関数は呼ばれない。

サポート終了の少し前に追加された関数。

```lua
function onGameOver()
  SCREENMAN:SystemMessage("Game Over")
end
```
</details>
<details>
<summary>function onInputDown(touchId, posX, screenPosX, screenPosY)</summary>

画面上で指をダウンして入力判定があった時に呼ばれるイベント関数。

onInputのイベント関数はAutoPlayでは呼び出されない。

|引数|説明|
|-|-|
|touchId|指のタッチ番号|
|posX|レーン上のX座標|
|screenPosX|スクリーン座標系のX座標|
|screenPosY|スクリーン座標系のY座標|

```lua
function onInputDown(touchId, posX, screenPosX, screenPosY)
  local src={touchId,posX,screenPosX,screenPosY}
  local dst=table.concat(src,",")
  print(dst)
end
```
</details>
<details>
<summary>function onInputMove(touchId, posX, screenPosX, screenPosY)</summary>

画面上で指を動かして入力判定があった時に呼ばれるイベント関数。

|引数|説明|
|-|-|
|touchId|指のタッチ番号|
|posX|レーン上のX座標|
|screenPosX|スクリーン座標系のX座標|
|screenPosY|スクリーン座標系のY座標|

```lua
function onInputMove(touchId, posX, screenPosX, screenPosY)
  local src={touchId,posX,screenPosX,screenPosY}
  local dst=table.concat(src,",")
  print(dst)
end
```
</details>

<details>
<summary>function onInputUp(touchId, posX, screenPosX, screenPosY)</summary>

画面上で指をアップして入力判定があった時に呼ばれるイベント関数。

一度ダウン判定のあった指のタッチ番号のアップ判定はレーン外でも入力を受け付ける。

|引数|説明|
|-|-|
|touchId|指のタッチ番号|
|posX|レーン上のX座標|
|screenPosX|スクリーン座標系のX座標|
|screenPosY|スクリーン座標系のY座標|

```lua
function onInputUp(touchId, posX, screenPosX, screenPosY)
  local src={touchId,posX,screenPosX,screenPosY}
  local dst=table.concat(src,",")
  print(dst)
end
```
</details>
